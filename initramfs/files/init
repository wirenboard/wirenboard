#!/bin/busybox sh
/bin/busybox --install -s

/bin/mknod /dev/null c 1 3
/bin/mknod /dev/tty c 5 0

/bin/mount -a
/sbin/mdev -s

mkdir -p /dev/pts
mount /dev/pts

mkdir -p /dev/shm
mkdir -p /var/lock

EMMC=/dev/mmcblk0
RAMDISK="/tmp/ramdisk.img"
ALLOWED_FIT_NAMES="wb_update.fit wb6_update.fit wb_update_FACTORYRESET.fit wb6_update_FACTORYRESET.fit"
USBDIR="/usb"

BOOTMODE="$(sed -n 's/.*bootmode=\([^ ]*\).*/\1/p' /proc/cmdline)"
#BOOTMODE="usbupdate,wb6_update.fit"
echo "Boot mode: $BOOTMODE"

BOARD_FAMILY="wb6"
DT_COMPAT_LIST=`tr < /proc/device-tree/compatible  '\000' '\n'`

for compat in $DT_COMPAT_LIST; do
	case "$compat" in
		"contactless,imx6ul-wirenboard60" )
			echo "Board is WB6, loading ci_hdrc_imx module"
			BOARD_FAMILY="wb6"
			#load board-specific modules here
			modprobe ci_hdrc_imx
			sleep 1
			break
			;;
		"wirenboard,wirenboard-700" )
			echo "Board is WB7"
			BOARD_FAMILY="wb7"
			break
			;;
	esac
done

depmod

led() {
	echo "$3" > "/sys/class/leds/$1/$2" 2>/dev/null || true
}

set_led_update_in_progress() {
	led red trigger none
	led red brightness 0

	led green trigger timer
	led green delay_on 250
	led green delay_off 250
} 

set_led_prompt_user() {
	led red trigger timer
	led red delay_on 200
	led red delay_off 200

	led green trigger timer
	led green delay_on 200
	led green delay_off 200
} 


check_fit_end_signature() {
	local UPDATE_FIT_END_SIGNATURE="__WB_UPDATE_FIT_END__"

	local sig_len=`echo -n "$UPDATE_FIT_END_SIGNATURE" | wc -c`
	local sig=`tail -c $sig_len "$1"`
	[[ "$sig" == "$UPDATE_FIT_END_SIGNATURE" ]]
}

search_for_usb_drive() {
	echo "Load modules for USB to work"
	modprobe usb-storage
	modprobe sd_mod

	local USB_SETTLE_TIME=10
	local COUNT=0
	while [[ ! -e /dev/sda1 && $COUNT -lt $USB_SETTLE_TIME ]]; do
		echo -ne "Waiting for USB to settle ($((COUNT+1))/$USB_SETTLE_TIME)\\r"
		sleep 1
		let COUNT++
	done
	echo

	# Look for any usb storage devices
	ls /dev/sd* >/dev/null 2>&1
}

# Search for .fit files in a given directory and run update
#
# @param $1 directory to look for .fit files
# @param $2 list of allowable .fit file names
# @param $3 human-readable source name
update_from_fs() {
	local DIR="$1"
	local FIT_NAMES="$2"
	local SOURCE="$3"

	local FOUND_FIT_NAME=""
	for FNAME in ${FIT_NAMES}; do
		local FIT="$DIR/$FNAME"
		if [[ -e "${FIT}" ]]; then
			if [[ ! -z "${FOUND_FIT_NAME}" ]]; then
				echo "ERROR: multiple .fit found on ${SOURCE} (${DIR}): ${FOUND_FIT_NAME} and ${FNAME}. Leave just one from a list: ${FIT_NAMES}"
				exit 1
			fi

			FOUND_FIT_NAME="$FNAME"
		fi
	done

	if [[ ! -z "$FOUND_FIT_NAME" ]]; then
		local FIT="$DIR/$FOUND_FIT_NAME"

		echo "Will use ${FOUND_FIT_NAME} from ${SOURCE} (${DIR})"
		if [[ "x${CONFIRM}" == "xy" ]]; then
			set_led_prompt_user
			echo "Press FW button to confirm updating from ${SOURCE} (${DIR})"
			USE_BUZZER=n USE_ECHO=y WAIT_TIME=10 HOLD_TIME=0 wait_for_button 1>&2
			local result=$?
			if [[ $result != 0 ]]; then
				echo "ERROR: update is not confirmed, exiting"
				exit 1
			fi
		fi

		check_fit_end_signature "$FIT" &&
			set_led_update_in_progress &&
			wb-run-update --from-initramfs --no-mqtt --no-remove "$FIT" &&
			break
	fi
	
}

# @param $1 .fit filename. If blank, look for all possible file names
update_from_usb_drive() {
	local FIT_NAME="$1"
	if [[ -z "${FIT_NAME}" ]]; then
		local FIT_NAMES="${ALLOWED_FIT_NAMES}"
	else
		local FIT_NAMES="${FIT_NAME}"
	fi

	mkdir -p "$USBDIR"

	for USBDEV in /dev/sd*; do
		echo "Looking for update .fit on ${USBDEV}..."

		umount "$USBDIR" >/dev/null 2>&1 || true
		mount -t auto "$USBDEV" "$USBDIR" >/dev/null 2>&1 || continue
		cleanup() {
			umount "$USBDIR"
		}
		trap cleanup EXIT

		update_from_fs "${USBDIR}" "${FIT_NAMES}" "USB drive"
	done
}

wait_for_emmc() {
	# wait for mmc stack to load
	echo "Wait for eMMC to become available..."
	while [ ! -b $EMMC ]; do
		sleep 1
		echo -n "."
	done
	echo
}

update_from_emmc() {
	local DATA_PART="${EMMC}p6"
	local FIT="/mnt/data/.wb-restore/factoryreset.fit"

	wait_for_emmc

	echo "Will use $FIT"

	mkdir -p /mnt/
	mkdir -p /mnt/data
	mount -t auto "${DATA_PART}" /mnt/data &&
		[[ -e "$FIT" ]] &&
		check_fit_end_signature "$FIT" &&
		wb-run-update  --from-initramfs --no-mqtt --no-remove "$FIT"
}

update_from_gadget() {
	mkdir -p "$USBDIR"
	mount -t vfat ${RAMDISK} "$USBDIR"
	echo "Will look for update in USB gadget ramdisk"
	update_from_fs "$USBDIR" "${ALLOWED_FIT_NAMES}" "USB gadget"
}

check_usb_gadget_connected() {
	[[ "x$(cat /sys/class/udc/*/current_speed)" != "xUNKNOWN" ]]
}

wait_for_gadget_disconnect() {
	local COUNT=0
	while check_usb_gadget_connected; do
		echo -ne "Copy .fit file to virtual USB driver and unplug the cable ($(($COUNT+1)))\\r"
		sleep 1
		let COUNT++
	done
	echo
	! check_usb_gadget_connected
}


wait_usb_gadget_connected() {
	local WAIT_GADGET_TIME=7
	local COUNT=0
	while ! check_usb_gadget_connected && [[ $COUNT -lt $WAIT_GADGET_TIME ]]; do
		echo -ne "Waiting for USB gadget to connect to host PC ($(($COUNT+1))/$WAIT_GADGET_TIME)\\r"
		sleep 1
		let COUNT++
	done
	echo
	check_usb_gadget_connected
}

is_usb_gadget_supported() {
	[[ "${BOARD_FAMILY}" == "wb7" ]]
}

setup_usb_ram_mass_storage() {
		# create usb_mass_storage first
		dd if=/dev/zero of=${RAMDISK} bs=1M count=300
		mkfs.vfat ${RAMDISK}
		mkdir -p "$USBDIR"
		mount -t vfat ${RAMDISK} "$USBDIR"
		cp /usr/share/README.ramdisk.txt "${USBDIR}/README.txt"
		umount "$USBDIR"

		echo "Activate Mass Storage device"
		modprobe g_mass_storage file=${RAMDISK} iManufacturer="Wiren Board" iProduct="Wiren Board RAM disk"
}

setup_usb_ssh() {
	echo "Activate USB Ethernet device..."
	usb_net up
	echo "Now you can access device by ssh: ssh root@192.168.41.1"
	dropbear -F -E
}

start_debug_console() {
	TTY=/dev/console
	exec setsid sh -c "exec sh <$TTY >$TTY 2>&1"
}

trap 'start_debug_console' EXIT

case "$BOOTMODE" in
	update_auto)
		is_usb_gadget_supported && setup_usb_ram_mass_storage

		if is_usb_gadget_supported && wait_usb_gadget_connected; then
			wait_for_gadget_disconnect
			update_from_gadget
		elif search_for_usb_drive; then
			CONFIRM=y update_from_usb_drive
		else
			update_from_emmc
		fi
		;;
	usbupdate*)
		FIT_NAME="${BOOTMODE#*,}"
		[[ "${FIT_NAME}" == "usbupdate" ]] && FIT_NAME="update.fit"

		search_for_usb_drive &&
			update_from_usb_drive ${FIT_NAME}
		;;
	usbgadget|*)
		FLAG=/flag

		# create usb_mass_storage first
		dd if=/dev/zero of=$FLAG bs=1K count=1

		wait_for_emmc

		echo "Activate Mass Storage device"
		led red trigger mmc0
		modprobe g_mass_storage file=$EMMC,$FLAG iManufacturer="Wiren Board" iProduct="Wiren Board"
		while [ "x" == "x$_FLAG" ]; do sleep 2; _FLAG=`cat $FLAG`; done

		echo "Deactivate Mass Storage device and reread partition table"
		modprobe -r g_mass_storage
		sleep 1
		blockdev --rereadpt $EMMC
		sleep 1

		setup_usb_ssh &
		;;
esac


sleep 1
start_debug_console
